let Videos,ffmpeg,JSZip;_46f‍.x([["writeFile",()=>writeFile],["readFile",()=>readFile],["storeVideo",()=>storeVideo],["trimVideo",()=>trimVideo],["convertSubtitlesToSrt",()=>convertSubtitlesToSrt],["createPayloadZip",()=>createPayloadZip]]);_46f‍.w("../models/videos",[["default",["Videos"],function(v){Videos=v}]]);_46f‍.w("fluent-ffmpeg",[["default",["ffmpeg"],function(v){ffmpeg=v}]]);_46f‍.w("jszip",[["default",["JSZip"],function(v){JSZip=v}]]);



const ffmpegPath = require('@ffmpeg-installer/ffmpeg').path;
ffmpeg.setFfmpegPath(ffmpegPath);

const GAME_DATA_BASE = '/var/game-data';

let uuidv4 = () => {
    return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
      (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
    );
  }

       let writeFile = (filePath, byteStream) => {
    return new Promise((resolve, reject) => {
        fs.writeFile(filePath, byteStream, (err) => {
            if (err) {
                return reject(err);
            }

            return resolve();
        })
    });
}

       let readFile = (filePath) => {
    return new Promise((resolve, reject) => {
        fs.readFile(filePath, (err, data) => {
            if (err) {
                return reject(err);
            }

            return resolve(data);
        })
    })
}

let convertSecondsToTimestamp = (seconds) => {
    let h = Math.floor(seconds / 3600);
    let m = Math.floor((seconds % 3600) / 60);
    let s = Math.floor(seconds % 60);
    let ms = Math.floor((seconds - Math.trunc(seconds)) * 1000);

    return `${h.toString().padStart(2, "0")}:${m.toString().padStart(2, "0")}:${s.toString().padStart(2, "0")},${ms.toString().padStart(3, "0")}`;
}

       let storeVideo = async (videoByteStream, twitchUserId, subtitles) => {
    var videoPath = `${GAME_DATA_BASE}/videos/${uuidv4()}.mp4`;

    try {
        await writeFile(videoPath, videoByteStream);
        return await Videos.create({
            videoPath,
            twitchUserId,
            subtitles
        });
    } catch (error) {
        throw new Error("Unable to create entr: " + error);
    }
}

let processVideo = (inputFilePath, outputFilePath, startTime, duration) => {
    return new Promise((resolve, reject) => {
        // Process video
        ffmpeg(inputFilePath)
        .setStartTime(convertSecondsToTimestamp(startTime))
        .setDuration(duration)
        .output(outputFilePath)
        .on('end', function(err) {
            if(!err) { 
                resolve();
            }
        })
        .on('error', function(err){
            reject(err);
        }).run();
    });
}

       let trimVideo = async (videoByteStream, startTime, endTime) => {
    var buffer = Buffer.from(videoByteStreamBase64, "base64");
    var inputFilePath = `/tmp/working/${uuidv4()}-in.mp4`;
    var outputFilePath = `/tmp/working/${uuidv4()}-in.mp4`;
    try {
        await writeFile(inputFilePath, buffer);
        await processVideo(inputFilePath, outputFilePath, startTime, endTime - startTime);
        return await readFile(outputFilePath);
    } catch (err) {
        throw new Error("Unable to trim video: " + err);
    }
}

       let convertSubtitlesToSrt = (subtitles) => {
    return subtitles.map((subtitle, index) => {
        return (
        ```${index}
        ${convertSecondsToTimestamp(subtitle.startTime)} --> ${convertSecondsToTimestamp(subtitle.endTime)}
        ${subtitle.text}```
        );
    }).join("\n");
}

       let createPayloadZip = async (byteStream, subtitles) => {
    let zip = new JSZip();
    let root = zip
        .folder("WhatTheDub_Data")
        .folder("StreamingAssets");

    let baseFileName = `${uuidv4()}`;
    
    root
        .folder("Subtitles")
        .file(`${baseFileName}.srt`, convertSubtitlesToSrt(subtitles));
    root
        .folder("VideoClips")
        .file(`${baseFileName}.mp4`, byteStream);

    return `data:application/zip;base64,${await zip.generateAsync({type:"base64"})}`;
}